// Package bots provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package bots

import (
	"encoding/json"
	"errors"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AlwaysPredicateType.
const (
	Always AlwaysPredicateType = "always"
)

// Defines values for EdgeOperation.
const (
	Append EdgeOperation = "append"
	Noop   EdgeOperation = "noop"
	Save   EdgeOperation = "save"
)

// Defines values for ExactPredicateType.
const (
	Exact ExactPredicateType = "exact"
)

// Defines values for RegexPredicateType.
const (
	Regex RegexPredicateType = "regex"
)

// Defines values for Status.
const (
	Dead    Status = "dead"
	Idle    Status = "idle"
	Running Status = "running"
)

// AlwaysPredicate Переход по ребру осуществляется на любое сообщение пользователя.
type AlwaysPredicate struct {
	Type AlwaysPredicateType `json:"type"`
}

// AlwaysPredicateType defines model for AlwaysPredicate.Type.
type AlwaysPredicateType string

// Bot defines model for Bot.
type Bot struct {
	// Author ID пользователя - автора бота.
	Author int64 `json:"author"`

	// Enabled Автозапуск бота
	Enabled bool `json:"enabled"`

	// Id Уникальный ID бота.
	Id string `json:"id"`

	// Script Сценарий бота.
	Script Script `json:"script"`

	// Token Телеграм токен для бота, полученный в @BotFather.
	Token string `json:"token"`
}

// Edge Обозначают связь между узлами как переход в результате ответа пользователя.
type Edge struct {
	// Operation Действие, которое выполнится в результате перехода пользователя по ребру. - noop. Ничего не происходит. Подходит для использования в меню и промежуточных узлах. - save. Сохраняет ответ или перезаписывает предыдущий. Подходит в большинстве ситуаций. - append. Добавляет ответ к предыдущему. Подходит для вопросов с множественным выбором.
	Operation EdgeOperation `json:"operation"`

	// Predicate Predicate описывает условие перехода по ребру.
	Predicate Predicate `json:"predicate"`

	// To State узла, к которому совершается переход.
	To int `json:"to"`
}

// EdgeOperation Действие, которое выполнится в результате перехода пользователя по ребру. - noop. Ничего не происходит. Подходит для использования в меню и промежуточных узлах. - save. Сохраняет ответ или перезаписывает предыдущий. Подходит в большинстве ситуаций. - append. Добавляет ответ к предыдущему. Подходит для вопросов с множественным выбором.
type EdgeOperation string

// Entry Точка входа в сценарий бота. Пользователь может вызвать точку входу командой /<entry> (как, например, /start). Может быть вызвана рассылкой по такому же ключу.
type Entry struct {
	// Key Ключ точки входа.
	Key string `json:"key"`

	// Start Указатель на State узла, с которого начинается выполнение сценария.
	Start int `json:"start"`
}

// Error defines model for Error.
type Error struct {
	union json.RawMessage
}

// Error2 defines model for .
type Error2 = []Error_2_Item

// Error_2_Item defines model for Error.2.Item.
type Error_2_Item struct {
	union json.RawMessage
}

// ExactPredicate Переход по ребру осуществляется при полном совпадении строки text с сообщением пользователя.
type ExactPredicate struct {
	Text string             `json:"text"`
	Type ExactPredicateType `json:"type"`
}

// ExactPredicateType defines model for ExactPredicate.Type.
type ExactPredicateType string

// InvalidInputError defines model for InvalidInputError.
type InvalidInputError struct {
	Code    string             `json:"code"`
	Details *map[string]string `json:"details,omitempty"`
	Message string             `json:"message"`
}

// Message Любое сообщение в Telegram. На данный момент описывается текстом, но в будущем добавится поддержка файлов.
type Message struct {
	Text string `json:"text"`
}

// Node Минимальная структурная единица сценария бота. Представляет собой сообщение (сообщения), которые отправляются пользователю. Ожидается ответ пользователя для перехода к следующему узлу.
type Node struct {
	// Edges Массив исходящих рёбер узла.
	Edges *[]Edge `json:"edges,omitempty"`

	// Messages Массив отправляемых ботом сообщений при вхождении в узел.
	Messages []Message `json:"messages"`

	// Options Массив кнопок (опций) ответа для пользователя.
	Options *[]string `json:"options,omitempty"`

	// State Уникальный номер узла в сценарии бота.
	State int `json:"state"`

	// Title Человеко-читаемое название узла. В таблице ответов будет отображаться как заголовок столбца.
	Title string `json:"title"`
}

// PlainError defines model for PlainError.
type PlainError struct {
	Message string `json:"message"`
}

// PostMailing defines model for PostMailing.
type PostMailing struct {
	// EntryKey Ключ точки входа, которая будет выполнена для списка пользователей.
	EntryKey string `json:"entryKey"`

	// Users Список пользователей, для которых будет выполнен скрипт начиная с точки входа entryKey.
	Users []int64 `json:"users"`
}

// Predicate Predicate описывает условие перехода по ребру.
type Predicate struct {
	union json.RawMessage
}

// PutBots defines model for PutBots.
type PutBots struct {
	// Id Уникальный ID бота.
	Id string `json:"id"`

	// Script Сценарий бота.
	Script Script `json:"script"`

	// Token Телеграм токен для бота, полученный в @BotFather.
	Token string `json:"token"`
}

// RegexPredicate Переход по ребру осуществляется при совпадении с регулярным выражением pattern.
type RegexPredicate struct {
	Pattern string             `json:"pattern"`
	Type    RegexPredicateType `json:"type"`
}

// RegexPredicateType defines model for RegexPredicate.Type.
type RegexPredicateType string

// Script Сценарий бота.
type Script struct {
	Entries []Entry `json:"entries"`
	Nodes   []Node  `json:"nodes"`
}

// Status Статус инстанса бота.
type Status string

// CreateBotJSONRequestBody defines body for CreateBot for application/json ContentType.
type CreateBotJSONRequestBody = PutBots

// MailingJSONRequestBody defines body for Mailing for application/json ContentType.
type MailingJSONRequestBody = PostMailing

// AsPlainError returns the union data inside the Error as a PlainError
func (t Error) AsPlainError() (PlainError, error) {
	var body PlainError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlainError overwrites any union data inside the Error as the provided PlainError
func (t *Error) FromPlainError(v PlainError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlainError performs a merge with any union data inside the Error, using the provided PlainError
func (t *Error) MergePlainError(v PlainError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidInputError returns the union data inside the Error as a InvalidInputError
func (t Error) AsInvalidInputError() (InvalidInputError, error) {
	var body InvalidInputError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidInputError overwrites any union data inside the Error as the provided InvalidInputError
func (t *Error) FromInvalidInputError(v InvalidInputError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidInputError performs a merge with any union data inside the Error, using the provided InvalidInputError
func (t *Error) MergeInvalidInputError(v InvalidInputError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsError2 returns the union data inside the Error as a Error2
func (t Error) AsError2() (Error2, error) {
	var body Error2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromError2 overwrites any union data inside the Error as the provided Error2
func (t *Error) FromError2(v Error2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeError2 performs a merge with any union data inside the Error, using the provided Error2
func (t *Error) MergeError2(v Error2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Error) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Error) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlainError returns the union data inside the Error_2_Item as a PlainError
func (t Error_2_Item) AsPlainError() (PlainError, error) {
	var body PlainError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlainError overwrites any union data inside the Error_2_Item as the provided PlainError
func (t *Error_2_Item) FromPlainError(v PlainError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlainError performs a merge with any union data inside the Error_2_Item, using the provided PlainError
func (t *Error_2_Item) MergePlainError(v PlainError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidInputError returns the union data inside the Error_2_Item as a InvalidInputError
func (t Error_2_Item) AsInvalidInputError() (InvalidInputError, error) {
	var body InvalidInputError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidInputError overwrites any union data inside the Error_2_Item as the provided InvalidInputError
func (t *Error_2_Item) FromInvalidInputError(v InvalidInputError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidInputError performs a merge with any union data inside the Error_2_Item, using the provided InvalidInputError
func (t *Error_2_Item) MergeInvalidInputError(v InvalidInputError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Error_2_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Error_2_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAlwaysPredicate returns the union data inside the Predicate as a AlwaysPredicate
func (t Predicate) AsAlwaysPredicate() (AlwaysPredicate, error) {
	var body AlwaysPredicate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAlwaysPredicate overwrites any union data inside the Predicate as the provided AlwaysPredicate
func (t *Predicate) FromAlwaysPredicate(v AlwaysPredicate) error {
	v.Type = "always"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAlwaysPredicate performs a merge with any union data inside the Predicate, using the provided AlwaysPredicate
func (t *Predicate) MergeAlwaysPredicate(v AlwaysPredicate) error {
	v.Type = "always"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExactPredicate returns the union data inside the Predicate as a ExactPredicate
func (t Predicate) AsExactPredicate() (ExactPredicate, error) {
	var body ExactPredicate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExactPredicate overwrites any union data inside the Predicate as the provided ExactPredicate
func (t *Predicate) FromExactPredicate(v ExactPredicate) error {
	v.Type = "exact"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExactPredicate performs a merge with any union data inside the Predicate, using the provided ExactPredicate
func (t *Predicate) MergeExactPredicate(v ExactPredicate) error {
	v.Type = "exact"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRegexPredicate returns the union data inside the Predicate as a RegexPredicate
func (t Predicate) AsRegexPredicate() (RegexPredicate, error) {
	var body RegexPredicate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegexPredicate overwrites any union data inside the Predicate as the provided RegexPredicate
func (t *Predicate) FromRegexPredicate(v RegexPredicate) error {
	v.Type = "regex"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegexPredicate performs a merge with any union data inside the Predicate, using the provided RegexPredicate
func (t *Predicate) MergeRegexPredicate(v RegexPredicate) error {
	v.Type = "regex"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Predicate) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Predicate) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "always":
		return t.AsAlwaysPredicate()
	case "exact":
		return t.AsExactPredicate()
	case "regex":
		return t.AsRegexPredicate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Predicate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Predicate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
