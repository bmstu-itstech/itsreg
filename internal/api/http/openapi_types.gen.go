// Package http provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package http

import (
	"encoding/json"
	"errors"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AlwaysPredicateType.
const (
	Always AlwaysPredicateType = "always"
)

// Defines values for EdgeOperation.
const (
	Append EdgeOperation = "append"
	Noop   EdgeOperation = "noop"
	Save   EdgeOperation = "save"
)

// Defines values for ExactPredicateType.
const (
	Exact ExactPredicateType = "exact"
)

// Defines values for RegexpPredicateType.
const (
	Regexp RegexpPredicateType = "regexp"
)

// AlwaysPredicate Переход по ребру осуществляется на любое сообщение пользователя.
type AlwaysPredicate struct {
	Type AlwaysPredicateType `json:"type"`
}

// AlwaysPredicateType defines model for AlwaysPredicate.Type.
type AlwaysPredicateType string

// Bot defines model for Bot.
type Bot struct {
	// Author ID пользователя - автора бота.
	Author int64 `json:"author"`

	// Id Уникальный ID бота.
	Id string `json:"id"`

	// Script Сценарий бота.
	Script Script `json:"script"`

	// Token Телеграм токен для бота, полученный в @BotFather.
	Token string `json:"token"`
}

// Edge Обозначают связь между узлами как переход в результате ответа пользователя.
type Edge struct {
	// Operation Действие, которое выполнится в результате перехода пользователя по ребру. - noop. Ничего не происходит. Подходит для использования в меню и промежуточных узлах. - save. Сохраняет ответ или перезаписывает предыдущий. Подходит в большинстве ситуаций. - append. Добавляет ответ к предыдущему. Подходит для вопросов с множественным выбором.
	Operation EdgeOperation `json:"operation"`

	// Predicate Predicate описывает условие перехода по ребру.
	Predicate Predicate `json:"predicate"`

	// To State узла, к которому совершается переход.
	To int `json:"to"`
}

// EdgeOperation Действие, которое выполнится в результате перехода пользователя по ребру. - noop. Ничего не происходит. Подходит для использования в меню и промежуточных узлах. - save. Сохраняет ответ или перезаписывает предыдущий. Подходит в большинстве ситуаций. - append. Добавляет ответ к предыдущему. Подходит для вопросов с множественным выбором.
type EdgeOperation string

// Entry Точка входа в сценарий бота. Пользователь может вызвать точку входу командой /<entry> (как, например, /start). Может быть вызвана рассылкой по такому же ключу.
type Entry struct {
	// Key Ключ точки входа.
	Key string `json:"key"`

	// Start Указатель на State узла, с которого начинается выполнение сценария.
	Start int `json:"start"`
}

// Error defines model for Error.
type Error struct {
	Message string  `json:"message"`
	Slug    *string `json:"slug,omitempty"`
}

// ExactPredicate Переход по ребру осуществляется при полном совпадении строки text с сообщением пользователя.
type ExactPredicate struct {
	Text string             `json:"text"`
	Type ExactPredicateType `json:"type"`
}

// ExactPredicateType defines model for ExactPredicate.Type.
type ExactPredicateType string

// Message Любое сообщение в Telegram. На данный момент описывается текстом, но в будущем добавится поддержка файлов.
type Message struct {
	Text string `json:"text"`
}

// Node Минимальная структурная единица сценария бота. Представляет собой сообщение (сообщения), которые отправляются пользователю. Ожидается ответ пользователя для перехода к следующему узлу.
type Node struct {
	// Edges Массив исходящих рёбер узла.
	Edges *[]Edge `json:"edges,omitempty"`

	// Messages Массив отправляемых ботом сообщений при вхождении в узел.
	Messages []Message `json:"messages"`

	// Options Массив кнопок (опций) ответа для пользователя.
	Options *[]string `json:"options,omitempty"`

	// State Уникальный номер узла в сценарии бота.
	State int `json:"state"`

	// Title Человеко-читаемое название узла. В таблице ответов будет отображаться как заголовок столбца.
	Title string `json:"title"`
}

// Predicate Predicate описывает условие перехода по ребру.
type Predicate struct {
	union json.RawMessage
}

// PutBots defines model for PutBots.
type PutBots struct {
	// Id Уникальный ID бота.
	Id string `json:"id"`

	// Script Сценарий бота.
	Script Script `json:"script"`

	// Token Телеграм токен для бота, полученный в @BotFather.
	Token string `json:"token"`
}

// RegexpPredicate Переход по ребру осуществляется при совпадении с регулярным выражением pattern.
type RegexpPredicate struct {
	Pattern string              `json:"pattern"`
	Type    RegexpPredicateType `json:"type"`
}

// RegexpPredicateType defines model for RegexpPredicate.Type.
type RegexpPredicateType string

// Script Сценарий бота.
type Script struct {
	Entries []Entry `json:"entries"`
	Nodes   []Node  `json:"nodes"`
}

// CreateBotJSONRequestBody defines body for CreateBot for application/json ContentType.
type CreateBotJSONRequestBody = PutBots

// AsAlwaysPredicate returns the union data inside the Predicate as a AlwaysPredicate
func (t Predicate) AsAlwaysPredicate() (AlwaysPredicate, error) {
	var body AlwaysPredicate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAlwaysPredicate overwrites any union data inside the Predicate as the provided AlwaysPredicate
func (t *Predicate) FromAlwaysPredicate(v AlwaysPredicate) error {
	v.Type = "always"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAlwaysPredicate performs a merge with any union data inside the Predicate, using the provided AlwaysPredicate
func (t *Predicate) MergeAlwaysPredicate(v AlwaysPredicate) error {
	v.Type = "always"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExactPredicate returns the union data inside the Predicate as a ExactPredicate
func (t Predicate) AsExactPredicate() (ExactPredicate, error) {
	var body ExactPredicate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExactPredicate overwrites any union data inside the Predicate as the provided ExactPredicate
func (t *Predicate) FromExactPredicate(v ExactPredicate) error {
	v.Type = "exact"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExactPredicate performs a merge with any union data inside the Predicate, using the provided ExactPredicate
func (t *Predicate) MergeExactPredicate(v ExactPredicate) error {
	v.Type = "exact"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRegexpPredicate returns the union data inside the Predicate as a RegexpPredicate
func (t Predicate) AsRegexpPredicate() (RegexpPredicate, error) {
	var body RegexpPredicate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegexpPredicate overwrites any union data inside the Predicate as the provided RegexpPredicate
func (t *Predicate) FromRegexpPredicate(v RegexpPredicate) error {
	v.Type = "regexp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegexpPredicate performs a merge with any union data inside the Predicate, using the provided RegexpPredicate
func (t *Predicate) MergeRegexpPredicate(v RegexpPredicate) error {
	v.Type = "regexp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Predicate) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Predicate) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "always":
		return t.AsAlwaysPredicate()
	case "exact":
		return t.AsExactPredicate()
	case "regexp":
		return t.AsRegexpPredicate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Predicate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Predicate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
